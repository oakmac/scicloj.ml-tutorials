<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script id="state" type="text">"{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :initially-collapse? false, :auto-scroll? false, :port 5678, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Sun Dec 18 22:02:10 CET 2022\"] nil [:hr]], :custom-footer [:div [:hr] [:hr]]}, :ids [\"348\" \"350\" \"352\" \"354\" \"356\" \"358\" \"360\" \"362\" \"364\" \"366\" \"368\" \"370\" \"372\" \"374\" \"376\" \"378\" \"380\" \"382\" \"384\" \"386\" \"388\" \"390\" \"392\" \"394\" \"396\" \"398\" \"400\" \"402\" \"404\" \"406\" \"408\" \"410\" \"412\" \"414\" \"416\" \"418\" \"420\" \"422\" \"424\" \"426\" \"428\" \"430\" \"432\" \"434\" \"436\" \"438\" \"440\" \"442\" \"444\" \"446\" \"448\" \"450\" \"452\" \"454\" \"456\" \"458\" \"460\" \"462\" \"464\" \"466\" \"468\" \"470\" \"472\" \"474\" \"476\" \"478\" \"480\" \"482\" \"484\" \"486\" \"488\" \"490\" \"492\" \"494\" \"496\" \"498\" \"500\" \"502\" \"504\" \"506\" \"508\" \"510\" \"512\" \"514\" \"516\" \"518\" \"520\" \"522\" \"524\" \"526\" \"528\" \"530\" \"532\" \"534\" \"536\" \"538\" \"540\" \"542\" \"544\" \"546\" \"548\" \"550\" \"552\" \"554\" \"556\" \"558\" \"560\" \"562\" \"564\" \"566\" \"568\" \"570\" \"572\" \"574\" \"576\" \"578\" \"580\" \"582\" \"584\" \"586\" \"588\" \"590\" \"592\" \"594\" \"596\" \"598\" \"600\" \"602\" \"604\" \"606\" \"608\" \"610\" \"612\" \"614\" \"616\" \"618\" \"620\" \"622\" \"624\" \"626\" \"628\" \"630\" \"632\" \"634\" \"636\" \"638\" \"640\" \"642\" \"644\" \"646\"], :id->content {\"388\" [:div [:p] nil nil [:p/markdown \"The second alternative is to capture the state of the ctx in arbitrary\\n steps.\"]], \"392\" [:div [:p] [:div [:p/code {:code \"(def ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"528\" [:div [:p] nil nil [:p/markdown \"The sequence of pipeline functions consists for this example of a sequence with a single pipeline.\"]], \"582\" [:div [:p] nil nil [:p/markdown \"Now we will **generate** our seq of pipeline functions.\\nFirst we need a function which creates a pipeline function\\nfrom parameters:\"]], \"458\" [:div [:p] nil nil [:p/markdown \"In this chapter we see how to build a custom metamorph compliant function, which behaves like a simple model.\\nIt takes the mean of the training data and applies this the to the test data.\\nSo this function need to behave differently in mode: fit then in mode :transform.\\n\"]], \"370\" [:div [:p] nil nil [:p/markdown \"The function `scicloj.ml.core/model` stores the feature-dataset and the inference-target-dataset in the ctx before doing a prediction\\nat keys `:scicloj.metamorph.ml/feature-ds` and  `:scicloj.metamorph.ml/target-ds`\"]], \"422\" [:div [:p] nil nil [:p/markdown \"1. Inline\\n  2. Lifting\\n  3. Named function\\n\"]], \"432\" [:div [:p] nil nil [:p/markdown \"Here we first create a function which manipulates the dataset as we want\"]], \"438\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-lift\\n  (ml/pipeline\\n   (ml/lift ds->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"612\" [:div [:p] [:div [:p/code {:code \"((comp :metric :train-transform) best-result)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"0.7927590511860175\\n\"}]], \"402\" [:div [:p] nil nil [:p/markdown \"Custom steps in metamorph pipelines are normal Clojure functions.\"]], \"450\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-inline {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"466\" [:div [:p] nil nil [:p/markdown \"Next we create the model function. It makes use of namespaced\\nkey destructuring, which allows very compact code.\\n\\nThe :id,:data and :mode keys from the context,\\nbecome local bindings.\\n\\nIn :mode :fit, we calculate the mean of the (training) data and store it in ctx under an `id` which is passed to\\nthe function by `metamorph` and is a unique id of the step.\\nThis we use then as key to store the mean in the context, so that in :transform we can read it from the ctx under the same `id`.\\nThe `id` passed into the function is the same in :fit and :transform (but unique per step)\\nSo we see how to pass data from the same function in the pipeline run in mode :fit to the\\nrun in mode :transform.\\n\\nConceptually this function is a pair of train/predict functions, which behaves like `train` in mode :fit and\\n`predict` in mode :transform.\\n\"]], \"382\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mm/select-columns [:time])))\", :bg-class \"bg-light\"}]] nil nil], \"452\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-lift {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n}\\n\"}]], \"572\" [:div [:p] nil nil [:p/markdown \"Running the evaluation of the 2 pipeline functions\"]], \"498\" [:div [:p] nil nil [:p/markdown \"Differently to other machine learning frameworks, `scicloj.ml` does not only\\nallow to hyper-tune the model parameters but as well the whole transformation pipeline.\"]], \"488\" [:div [:p] nil nil [:p/markdown \"### Keep auxiliary data in pipeline\"]], \"380\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3]\\n               :val [1 3 4]}))\", :bg-class \"bg-light\"}]] nil nil], \"384\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"430\" [:div [:p] nil nil [:p/markdown \"### Lift a dataset->dataset function\"]], \"584\" [:div [:p] [:div [:p/code {:code \"(defn create-pipe-fn [params]\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass :Sex])\\n   (mm/categorical->number [:Survived :Pclass :Sex])\\n   (mm/set-inference-target :Survived)\\n   {:metamorph/id :model} (mm/model (merge {:model-type :smile.classification/logistic-regression}\\n                                           params))))\", :bg-class \"bg-light\"}]] nil nil], \"530\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines [pipe-fn])\", :bg-class \"bg-light\"}]] nil nil], \"616\" [:div [:p] [:div [:p/code {:code \"((comp :metric :train-transform) best-result)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"0.7927590511860175\\n\"}]], \"408\" [:div [:p] nil nil [:p/markdown \"## Custom dataset->dataset transforming functions \"]], \"600\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                         train-test-data-pairs\\n                                         ml/classification-accuracy\\n                                         :accuracy\\n                                         {:map-fn :map\\n                                          :return-best-pipeline-only false\\n                                          :return-best-crossvalidation-only false}))\", :bg-class \"bg-light\"}]] nil nil], \"552\" [:div [:p] nil nil [:p/markdown \"We can get the accuracy of the one result by doing:\"]], \"508\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines)\", :bg-class \"bg-light\"}]] nil nil], \"604\" [:div [:p] [:div [:p/code {:code \"(frequencies\\n (map (comp :metric :train-transform)\\n      (flatten eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"{0.7802746566791511 20,\\n 0.7827715355805243 20,\\n 0.7852684144818975 20,\\n 0.7865168539325843 40,\\n 0.787765293383271 40,\\n 0.7890137328339576 20,\\n 0.7888888888888889 20,\\n 0.7927590511860175 20}\\n\"}]], \"368\" [:div [:p] nil nil [:p/markdown \"Two functions in `scicloj.ml` use two further keys with the purpose of model evaluation, see further down in this guide.\"]], \"522\" [:div [:p] [:div [:p/code {:code \"(def titanic-data\\n  (->   (ds/dataset \\\"https://github.com/scicloj/metamorph-examples/raw/main/data/titanic/train.csv\\\"\\n                    {:key-fn keyword\\n                     :parser-fn :string})))\", :bg-class \"bg-light\"}]] nil nil], \"364\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n;;  step 1\\n;;  step 2\\n   {:metamorph/id :my-model} (mm/select-columns [:time])))\", :bg-class \"bg-light\"}]] nil nil], \"404\" [:div [:p] nil nil [:p/markdown \"Conceptually we have three types of functions, they differ by which keys in\\n the context they manipulate.\"]], \"520\" [:div [:p] nil nil [:p/markdown \"First the data:\"]], \"454\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-mm {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"504\" [:div [:p] nil nil [:p/markdown \"By preparing the seq of pipelines and the seq of train/test pairs accordingly,\\nvarious types of grid search with various cross-validation schemes can be realized.\"]], \"448\" [:div [:p] nil nil [:p/markdown \"The results of applying all 3 pipeline functions is the same.\"]], \"532\" [:div [:p] nil nil [:p/markdown \"For creating train/test pairs, the function `scicloj.ml.dataset/split->seq`\\n creates them in the right format (list of maps with keys :train and :test and value being\\na `tech.ml.dataset`)\"]], \"396\" [:div [:p] [:div [:p/code {:code \"ctx-2\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n| :time |\\n|------:|\\n|     1 |\\n|     2 |\\n|     3 |\\n, :mode :fit, :id #uuid \\\"7a36f5a4-1809-45f6-a3e8-c9049dbc5e25\\\"}\\n\"}]], \"634\" [:div [:p] [:div [:p/code {:code \"(def best-fit-ctx\\n  (:fit-ctx best-result))\", :bg-class \"bg-light\"}]] nil nil], \"394\" [:div [:p] [:div [:p/code {:code \"ctx-1\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 2]:\\n\\n| :time | :val |\\n|------:|-----:|\\n|     1 |    1 |\\n|     2 |    3 |\\n|     3 |    4 |\\n, :mode :fit, :id #uuid \\\"d974d23c-0656-44dc-ab30-91ea5ebae294\\\"}\\n\"}]], \"414\" [:div [:p] nil nil [:p/markdown \"Lets take as an example, a function which encodes a column with a numerical value to 3 categorical values:\\n\\n\\n - < 0         -> :negative\\n - > 0 - 1000  -> :low\\n - > 1000      -> :high\\n\\n \"]], \"462\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3 4 5 6 7 8 9 10]\\n               :val [1 3 4 4 20 3 4 18 39 23]}))\", :bg-class \"bg-light\"}]] nil nil], \"480\" [:div [:p] [:div [:p/code {:code \"(def predicted-ctx\\n  (pipe-fn\\n   (merge trained-ctx\\n          {:metamorph/data test-data\\n           :metamorph/mode :transform})))\", :bg-class \"bg-light\"}]] nil nil], \"630\" [:div [:p] [:div [:p/code {:code \"(def best-pipe-fn\\n  (:pipe-fn best-result))\", :bg-class \"bg-light\"}]] nil nil], \"472\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mean-model)))\", :bg-class \"bg-light\"}]] nil nil], \"644\" [:div [:p] nil nil nil], \"556\" [:div [:p] nil nil [:p/markdown \"#### Evaluate several pipeline fns using k-fold with Titanic example - 2 pipeline functions\"]], \"588\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn (create-pipe-fn {:max-iterations 1}))\", :bg-class \"bg-light\"}]] nil nil], \"426\" [:div [:p] nil nil [:p/markdown \"We can define inline a metamorph compliant function as anonymous function.\"]], \"492\" [:div [:p] nil nil [:p/markdown \"### Pipeline evaluation and selection\"]], \"632\" [:div [:p] nil nil [:p/markdown \"the best context\"]], \"442\" [:div [:p] nil nil [:p/markdown \"We write directly a metamorph compliant, named , function.\\nThe body of the function is the same as the body of the inline function from before.\\n\"]], \"592\" [:div [:p] [:div [:p/code {:code \"(def all-options\\n  (->>\\n   (ml/sobol-gridsearch {:max-iterations (ml/linear 1 1000 100 :int)\\n                         :lambda (ml/linear 0 1)\\n                          :tolerance (ml/linear 1e-9 1e-1 20)})\\n   (take 20)))\", :bg-class \"bg-light\"}]] nil nil], \"490\" [:div [:p] nil nil [:p/markdown \"As the context is a normal map, we can store arbitrary data in it. This means normally, that two steps work\\ntogether in some form, and a former steps writes some data to the ctx under a `known` key, which the later step\\nreads from the pipeline under this `known, shared` key.\\nThe use cases for this  are left for the user of `scicloj.ml` to decide, the library does not interfere in this.\\n\\nThe moment these functions become re-usable and are eventually added to a library, namespaced keywords should\\nbe used for the keys in order to avoid name collisions.\\n\\nTypical use cases might be:\\n\\n1. Some values of the dataset have been converted in some form, and we need to keep some information to convert them back\\n2. In a Natural Language Processing pipeline, the vocabulary is generated in one pipeline step, and needs to be used later\\n3. Some non-tabular data is generated during pipeline execution and should be kept somewhere\\n\\nThis features makes sure, that a pipeline can stay 100 % self-contained,\\nwhatever data needed to be stored and makes the metamorph pipeline concept future-proof.\\n\\n\"]], \"358\" [:div [:p] nil nil [:p/markdown \"`:metamorph/mode` is used by 'model' functions, which get fitted from data or transform data.\\nTwo modes are standardized, namely: `:fit` and `:transform`. In machine learning they often are called train / predict.\\n`sciform.ml` requires them to be `:fit` and `:transform`, and\\nthird party libraries should adhere to this convention.\\n\"]], \"484\" [:div [:p] [:div [:p/code {:code \"(def prediction\\n  (:metamorph/data predicted-ctx))\", :bg-class \"bg-light\"}]] nil nil], \"586\" [:div [:p] nil nil [:p/markdown \"This function can now be called to produce a pipeline fn:\"]], \"476\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"598\" [:div [:p] nil nil [:p/markdown \"Evaluating all 20 pipeline functions:\"]], \"354\" [:div [:p] nil nil [:p/markdown \"A metamorph context map can contain arbitrary keys. Three keys are\\n special and they enable the functioning of the pipeline . All steps should\\nhandle them in the same way.\"]], \"374\" [:div [:p] nil nil [:p/markdown \"## Debugging a metamorph pipeline\"]], \"456\" [:div [:p] nil nil [:p/markdown \"### Custom model function\"]], \"362\" [:div [:p] nil nil [:p/markdown \"By default the value of `:metamorph/id` is set to a unique uuid. In some cases it can be useful to overwrite this auto-generated id.\\nThis can be done by pre-pending any step function with a map. The map gets merged with the usual context map for this step, before the\\nstep function is executed:\\n\"]], \"512\" [:div [:p] [:div [:p/code {:code \"(comment\\n  (ml/evaluate-pipelines all-pipelines train-test-data-pairs ml/classification-accuracy :accuracy))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"nil\\n\"}]], \"594\" [:div [:p] nil nil [:p/markdown \"This will produce an optimized search grid of all combinations of the\\noptions, by taking first larger and then smaller\\nintervals in the boundaries of the options.\\nSo taking the first 20 of these covers already the full space coarse-grained.\\nSee help of the ml/sobol-gridsearch for more information.\\nThis gives us 20 grid points for our parameter search,\\nwhich we can easily transform in a sequence of 20 pipeline functions:\"]], \"618\" [:div [:p] nil nil [:p/markdown \"Out of this we can get the trained logistic regression model\\n(in this case a Smile Java object), \"]], \"350\" [:div [:p] [:div [:p/code {:code \"(require  '[scicloj.ml.core :as ml]\\n          '[scicloj.ml.metamorph :as mm]\\n          '[scicloj.ml.dataset :as ds]\\n          '[tech.v3.datatype.functional :as fun])\", :bg-class \"bg-light\"}]] nil nil], \"544\" [:div [:p] nil nil [:p/markdown \"On high level, the result contains for every fold and every pipe-fn\\n (in this example we have only one fold and one pipe-fn), these keys with the\\nevaluation metrics and other information\"]], \"610\" [:div [:p] nil nil [:p/markdown \"with a classification accuracy of:\"]], \"420\" [:div [:p] nil nil [:p/markdown \"We have now three different ways to write a metamorph compliant function\"]], \"562\" [:div [:p] nil nil [:p/markdown \"And then we just create two pipeline function via copy/paste/adapt.\\n(In reality we wanted to do this with a pipeline creating function\\ntaking parameters, see below).\\n\"]], \"626\" [:div [:p] [:div [:p/code {:code \"(seq\\n (.coefficients best-logistic-regression-model))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(-0.6743920480364906 -2.4886104571396594 1.9421494910902433)\\n\"}]], \"356\" [:div [:p] nil nil [:p/markdown \" `:metamorph/data` contains the main data object, the pipeline\\n is supposed to manipulate. The type of object can be anything for `metamorph.ml`,\\nbut all functionality in `scicloj.ml` requires it to be a `tech.v3.dataset`\\n instance. For further information see in\\n [metamorph](https://github.com/scicloj/metamorph)\"]], \"554\" [:div [:p] [:div [:p/code {:code \"(:metric (first (first eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"nil\\n\"}]], \"428\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-inline\\n  (ml/pipeline\\n   (fn [{:metamorph/keys [data]}]\\n     (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds)))))))\", :bg-class \"bg-light\"}]] nil nil], \"636\" [:div [:p] nil nil [:p/markdown \"and use this for predicting on new data:\"]], \"400\" [:div [:p] nil nil [:p/markdown \"### Custom metamorph compliant function\"]], \"536\" [:div [:p] nil nil [:p/markdown \"This results in a sequence of lengt 1, having one train/test split.\"]], \"482\" [:div [:p] nil nil [:p/markdown \"This runs the pipeline again and we have the prediction available in :metamorph/data\"]], \"386\" [:div [:p] [:div [:p/code {:code \"trained-ctx\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n| :time |\\n|------:|\\n|     1 |\\n|     2 |\\n|     3 |\\n, :mode :fit}\\n\"}]], \"578\" [:div [:p] [:div [:p/code {:code \"(map   #(get-in % [:train-transform :metric]) (flatten eval-results))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(0.6029962546816479\\n 0.6067415730337079\\n 0.6092384519350811\\n 0.6160493827160494\\n 0.616729088639201\\n 0.6179775280898876\\n 0.6204744069912609\\n 0.6229712858926342\\n 0.6242197253433208\\n 0.6242197253433208\\n 0.5930087390761548\\n 0.5967540574282147\\n 0.599250936329588\\n 0.6017478152309613\\n 0.6029962546816479\\n 0.6037037037037037\\n 0.6092384519350811\\n 0.6129837702871411\\n 0.6142322097378277\\n 0.6154806491885144)\\n\"}]], \"496\" [:div [:p] nil nil [:p/markdown \"In this situation we can think about trying out all different pipeline\\nor model parameters and select the best automatically. In the context of the\\nmodel, this is typically called `hyper-parameter tuning`\"]], \"560\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs (ds/split->seq titanic-data :kfold {:k 10}))\", :bg-class \"bg-light\"}]] nil nil], \"564\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-1\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   {:metamorph/id :model}\\n   (mm/model {:model-type :smile.classification/logistic-regression\\n              :max-iterations 1})))\", :bg-class \"bg-light\"}]] nil nil], \"440\" [:div [:p] nil nil [:p/markdown \"### Metamorph compliant function\"]], \"590\" [:div [:p] nil nil [:p/markdown \"But we go one step further already and grid search over\\npotential values using sobol sequences\"]], \"548\" [:div [:p] nil nil [:p/markdown \"This result of `evaluate-pipelines` is documented in detail here:  [metamorph.ml](https://github.com/scicloj/metamorph.ml/blob/main/README.md#evaluate-pipelines)\"]], \"542\" [:div [:p] [:div [:p/code {:code \"(remove-deep\\n [:model-data]\\n eval-results)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(({:pipe-fn\\n   #object[scicloj.metamorph.core$pipeline$local_pipeline__44848 0x2992d944 \\\"scicloj.metamorph.core$pipeline$local_pipeline__44848@2992d944\\\"],\\n   :pipe-decl nil,\\n   :fit-ctx\\n   {:metamorph/mode :fit,\\n    :model\\n    {:options {:model-type :smile.classification/logistic-regression},\\n     :id #uuid \\\"ca9e0407-a89d-4b3c-9e1c-5d5501889460\\\",\\n     :feature-columns [:Pclass],\\n     :target-columns [:Survived],\\n     :target-categorical-maps\\n     {:Survived\\n      {:lookup-table {\\\"1\\\" 0, \\\"0\\\" 1},\\n       :src-column :Survived,\\n       :result-datatype :float64}},\\n     :scicloj.metamorph.ml/unsupervised? nil}},\\n   :metric-fn\\n   #object[scicloj.ml.core$classification_accuracy 0x3ec4636c \\\"scicloj.ml.core$classification_accuracy@3ec4636c\\\"],\\n   :timing-fit 7,\\n   :source-information nil,\\n   :train-transform\\n   {:other-metrices (),\\n    :timing 18,\\n    :ctx\\n    {:metamorph/mode :transform,\\n     :model\\n     {:feature-columns [:Pclass],\\n      :target-categorical-maps\\n      {:Survived\\n       {:lookup-table {\\\"1\\\" 0, \\\"0\\\" 1},\\n        :src-column :Survived,\\n        :result-datatype :float64}},\\n      :target-columns [:Survived],\\n      :scicloj.metamorph.ml/unsupervised? nil,\\n      :id #uuid \\\"ca9e0407-a89d-4b3c-9e1c-5d5501889460\\\",\\n      :options\\n      {:model-type :smile.classification/logistic-regression}}},\\n    :metric 0.6077441077441077,\\n    :min 0.6077441077441077,\\n    :mean 0.6077441077441077,\\n    :max 0.6077441077441077},\\n   :test-transform\\n   {:other-metrices (),\\n    :timing 12,\\n    :ctx\\n    {:metamorph/mode :transform,\\n     :model\\n     {:feature-columns [:Pclass],\\n      :target-categorical-maps\\n      {:Survived\\n       {:lookup-table {\\\"1\\\" 0, \\\"0\\\" 1},\\n        :src-column :Survived,\\n        :result-datatype :float64}},\\n      :target-columns [:Survived],\\n      :scicloj.metamorph.ml/unsupervised? nil,\\n      :id #uuid \\\"ca9e0407-a89d-4b3c-9e1c-5d5501889460\\\",\\n      :options\\n      {:model-type :smile.classification/logistic-regression}}},\\n    :metric 0.5993265993265993,\\n    :min 0.5993265993265993,\\n    :mean 0.5993265993265993,\\n    :max 0.5993265993265993},\\n   :loss-or-accuracy :accuracy}))\\n\"}]], \"352\" [:div [:p] nil nil [:p/markdown \"### Special keys in metamorph context map\"]], \"376\" [:div [:p] nil nil [:p/markdown \"A metamorph pipeline can be debugged by two simple techniques.\"]], \"534\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs (ds/split->seq titanic-data :holdout))\", :bg-class \"bg-light\"}]] nil nil], \"360\" [:div [:p] nil nil [:p/markdown \"`:metamorph/id` contains at every step a different , unique, id. A model function can use it\\nto store the trained model in :fit and use it it :transform for prediction\"]], \"474\" [:div [:p] nil nil [:p/markdown \"We run the training as usual, passing a map of data and mode :fit. (The id gets added automatically)\"]], \"540\" [:div [:p] nil nil [:p/markdown \"The result contains quite some information, I remove here the binary representation of\\nthe model for pretty printing purposes.\"]], \"524\" [:div [:p] nil nil [:p/markdown \"Now we create a seq of pipeline fns, in this case having only **one** pipeline function\"]], \"606\" [:div [:p] nil nil [:p/markdown \"Sorting the result by metric and taking the last, we can get the `best` performing model\"]], \"558\" [:div [:p] nil nil [:p/markdown \"First we will generate seq of 10 pairs of train/test using k-fold\"]], \"580\" [:div [:p] nil nil [:p/markdown \"#### Evaluate several pipeline with Titanic example - grid search pipelines\"]], \"568\" [:div [:p] nil nil [:p/markdown \"Just create seq of 2 pipeline functions\"]], \"518\" [:div [:p] nil nil [:p/markdown \"We will reuse the example from the Introduction user guide.\"]], \"470\" [:div [:p] nil nil [:p/markdown \"The pipeline has only one step, the model function itself.\"]], \"642\" [:div [:p] nil nil [:p/markdown \"Todo\"]], \"502\" [:div [:p] nil nil [:p/markdown \"The working horse for this is the `scicloj.ml/evaluate-pipelines` function.\\nIt takes as basic input a `sequence of pipeline functions` , a `sequence of pairs of train and test datasets`\\nand  a `metric function`. It will then do a nested loop of all pipelines and all\\ntrain/test pairs and calculate the given  model metrics for all combinations.\\n(which means to `train` and `evaluate` all pipelines using the train/test dataset pairs. \"]], \"576\" [:div [:p] nil nil [:p/markdown \"This gives 2 * 10 = 20 results:\"]], \"546\" [:div [:p] [:div [:p/code {:code \"(keys (first (first eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(:pipe-fn\\n :pipe-decl\\n :fit-ctx\\n :metric-fn\\n :timing-fit\\n :source-information\\n :train-transform\\n :test-transform\\n :loss-or-accuracy)\\n\"}]], \"640\" [:div [:p] nil nil [:p/markdown \"### Handling of categorical data\"]], \"510\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs)\", :bg-class \"bg-light\"}]] nil nil], \"538\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                         train-test-data-pairs\\n                                         ml/classification-accuracy\\n                                         :accuracy))\", :bg-class \"bg-light\"}]] nil nil], \"570\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines [pipe-fn-1 pipe-fn-2])\", :bg-class \"bg-light\"}]] nil nil], \"486\" [:div [:p] [:div [:p/code {:code \"prediction\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [5 2]:\\n\\n| :time | :val |\\n|------:|-----:|\\n|    11 | 11.9 |\\n|    12 | 11.9 |\\n|    13 | 11.9 |\\n|    14 | 11.9 |\\n|    15 | 11.9 |\\n\\n\"}]], \"596\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines\\n  (map create-pipe-fn all-options))\", :bg-class \"bg-light\"}]] nil nil], \"418\" [:div [:p] [:div [:p/code {:code \"(defn ->cat [x]\\n  (cond (< x 0 )          :negative\\n        (and (pos? x)\\n             (< x 1000) ) :low\\n        true              :high))\", :bg-class \"bg-light\"}]] nil nil], \"550\" [:div [:p] nil nil [:p/markdown \"By default the `evaluate-pipeline` filters out the datasets already from the result,\\nwhich would else wise be in as well. This can be configured in the options when calling it.\"]], \"410\" [:div [:p] nil nil [:p/markdown \"Most steps of a pipeline are about modifying the dataset, so most custom code will be here.\\nIn machine learning, this is as well known as feature engineering, as new features get created\\nfrom existing features.\"]], \"416\" [:div [:p] nil nil [:p/markdown \"First a helper function which does the above transformation of a single value\"]], \"434\" [:div [:p] [:div [:p/code {:code \"(defn ds->cat [ds]\\n  (ds/add-or-replace-column ds :val (fn [ds] (map ->cat (:val ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"398\" [:div [:p] nil nil [:p/markdown \"The context contains as well the dataset, which could be large.\\n So other tools for inspecting Clojure maps are usefull.\"]], \"602\" [:div [:p] nil nil [:p/markdown \"This gives 10 * 20 = 200 model performance results ( 10 folds times 20 pipeline)\\n for which I print here the distribution:\"]], \"390\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (fn [ctx] (def ctx-1 ctx) ctx)\\n   (mm/select-columns [:time])\\n   (fn [ctx] (def ctx-2 ctx) ctx)))\", :bg-class \"bg-light\"}]] nil nil], \"526\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   {:metamorph/id :model}\\n   (mm/model {:model-type :smile.classification/logistic-regression})))\", :bg-class \"bg-light\"}]] nil nil], \"444\" [:div [:p] [:div [:p/code {:code \"(defn mm->cat []\\n  (fn [{:metamorph/keys [data]}]\\n    (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds))))))\", :bg-class \"bg-light\"}]] nil nil], \"406\" [:div [:p] nil nil [:p/markdown \"1. Data manipulation functions. Use only :metamorph/data .\\n  2. Model type of functions. They use :metamorph/data , :metamorph/mode and :metamorph/id  and behave different in mode :fit and :mode transform. Eventually they use other keys in the context.\\n  2a. This variants of type 2), might use non standard keys to pass data between different steps and therefore collaborate.\\n\"]], \"614\" [:div [:p] nil nil [:p/markdown \"and a mean classification accuracy over all folds of:\"]], \"646\" [:div [:p] nil nil nil], \"366\" [:div [:p] nil nil [:p/markdown \"This map can have any key / value, which might be useful for injecting other static data into the pipeline.\"]], \"500\" [:div [:p] nil nil [:p/markdown \"#### evaluate-pipelines function\"]], \"460\" [:div [:p] nil nil [:p/markdown \"Here we create dummy training data, which is like a time series.\\nWe have values for time step 1-10, and want to predict (using the mean),\\nthe value for future time steps.\\n\"]], \"348\" [:div [:p] nil nil nil], \"424\" [:div [:p] nil nil [:p/markdown \"### Inline fn\"]], \"622\" [:div [:p] [:div [:p/code {:code \"best-logistic-regression-model\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#object[smile.classification.LogisticRegression$Binomial 0xfd1db \\\"smile.classification.LogisticRegression$Binomial@fd1db\\\"]\\n\"}]], \"412\" [:div [:p] nil nil [:p/markdown \"For a custom data manipulation function to be able to participate in a metamorph pipeline\\nit needs to:\\n\\n1. Take a context map as input\\n2. Return a context map\\n3. Modify the dataset at key :metamorph/data\\n4. Not change any other key ctx\\n\\n\"]], \"436\" [:div [:p] nil nil [:p/markdown \"and then we include it into the pipeline via\\nlifting the ds->ds function into\\na :metamorph/data -> :metamorph/data function\"]], \"446\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-mm\\n  (ml/pipeline\\n   (mm->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"566\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-2\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   {:metamorph/id :model}\\n   (mm/model {:model-type :smile.classification/logistic-regression\\n              :max-iterations 1000})))\", :bg-class \"bg-light\"}]] nil nil], \"514\" [:div [:p] nil nil [:p/markdown \"This will return the evaluations as a sequence of maps, as explained below.\"]], \"506\" [:div [:p] nil nil [:p/markdown \"By leaving it to the user to provide the seq of pipeline-fns,\\n the sequence of train/test pairs and the metric function,\\nthe `evaluate-pipelines` function can be applied to a large variety of used cases. We will see below some examples, how to generate this\\nsequences.\"]], \"478\" [:div [:p] nil nil [:p/markdown \"Same for the prediction, in mode :transform, merging in the trained-ctx but overwriting data and mode\"]], \"624\" [:div [:p] nil nil [:p/markdown \"to inspect its internals, like coefficients: \"]], \"516\" [:div [:p] nil nil [:p/markdown \"#### Evaluate one pipeline function with Titanic example   \"]], \"494\" [:div [:p] nil nil [:p/markdown \"In machine learning we come at a certain moment of the development of\\na data pipeline or a model to a point where we do not know any more for sure, if a certain\\nmodification of the pipeline or the model will improve the predictive\\nperformance any further or not.\"]], \"378\" [:div [:p] nil nil [:p/markdown \"The first is to comment out parts of the pipeline, run it and\\n inspect the pipe-fn result, namely the context.\"]], \"620\" [:div [:p] [:div [:p/code {:code \"(def best-logistic-regression-model\\n  (ml/thaw-model (get-in best-result [:fit-ctx :model])))\", :bg-class \"bg-light\"}]] nil nil], \"464\" [:div [:p] [:div [:p/code {:code \"(def test-data\\n  (ds/dataset {:time [11 12 13 14 15]\\n               :val [nil nil  nil nil nil]}))\", :bg-class \"bg-light\"}]] nil nil], \"468\" [:div [:p] [:div [:p/code {:code \"(defn mean-model []\\n  (fn [{:metamorph/keys [id data mode] :as ctx}]\\n    (case mode\\n      :fit\\n      (let [vals-so-far (-> data :val seq)\\n            mean-so-far (fun/mean vals-so-far)]\\n        (assoc ctx id mean-so-far))\\n      :transform\\n      (let [mean-so-far (get ctx id)\\n            updated-ds (-> data\\n                           (ds/add-or-replace-column :val mean-so-far))]\\n        (assoc ctx :metamorph/data updated-ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"608\" [:div [:p] [:div [:p/code {:code \"(def best-result\\n  (->> eval-results\\n       flatten\\n       (sort-by (comp :metric :train-transform))\\n       last))\", :bg-class \"bg-light\"}]] nil nil], \"628\" [:div [:p] nil nil [:p/markdown \"Or taking the best pipeleine,\"]], \"372\" [:div [:p] nil nil [:p/markdown \"These are then used by function `scicloj.ml.core/evaluate-pipelines` to do performance measurements of a model\"]], \"638\" [:div [:p] [:div [:p/code {:code \"(->\\n (best-pipe-fn\\n  (merge best-fit-ctx\\n         {:metamorph/data (-> titanic-data  (ds/shuffle {:seed 123})  (ds/head 500))\\n          :metamorph/mode :transform}))\\n :metamorph/data\\n (ds/column-values->categorical :Survived)\\n frequencies)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"{\\\"0\\\" 323, \\\"1\\\" 177}\\n\"}]], \"574\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                         train-test-data-pairs\\n                                         ml/classification-accuracy\\n                                         :accuracy\\n                                         ;; we return results of all pipelines and all folds\\n                                         ;; By default only the best fold of the best pipeline is returned\\n                                         {:return-best-pipeline-only false\\n                                          :return-best-crossvalidation-only false}))\", :bg-class \"bg-light\"}]] nil nil]}}"</script>
    <script src="gorilla-notes/js/compiled/main.js"></script>
</html>
